<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>gamble where you go</title>

  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin=""/>

  <style>
    :root{
      --accent: #ff3e00;
      --bg: #0f1724;
      --panel: #0b1220;
      --muted: #9aa4b2;
      --glass: rgba(255,255,255,0.03);
    }
    html,body,#map{height:100%;}
    body{
      margin:0;
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial;
      background: linear-gradient(180deg,var(--bg), #071023);
      color:#e6eef6;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
      height:100vh;
      display:flex;
      flex-direction:column;
    }

    .topbar{
      display:flex;
      gap:12px;
      align-items:center;
      padding:12px 16px;
      background:linear-gradient(180deg,var(--panel), rgba(255,255,255,0.02));
      box-shadow: 0 2px 10px rgba(2,6,23,0.6);
      z-index:1000;
    }
    .title{font-weight:600;font-size:18px}

    .controls{display:flex; gap:8px; align-items:center;}
    button.btn{
      background:var(--glass);
      border:1px solid rgba(255,255,255,0.04);
      color:inherit;
      padding:8px 12px;
      border-radius:8px;
      cursor:pointer;
      font-weight:600;
      transition:all .14s ease;
    }
    button.btn:active{transform:translateY(1px)}
    button.primary{background:linear-gradient(90deg,var(--accent), #ff6f3a); color:#081017; border:none}
    button.ghost{background:transparent; border:1px dashed rgba(255,255,255,0.04);}
    button.warn{background:linear-gradient(90deg,#e25656,#ff7f7f); color:#071017}
    .info{margin-left:auto; font-size:13px; color:var(--muted)}

    #map{flex:1}

    .instructions{
      padding:10px 16px;
      font-size:13px;
      background:rgba(255,255,255,0.02);
      border-top:1px solid rgba(255,255,255,0.02);
      color:var(--muted);
    }

    /* small responsive tweaks */
    @media (max-width:640px){
      .title{font-size:16px}
      .info{display:none}
    }

    /* pointer icon style inside marker */
    .map-pointer-icon{display:flex; align-items:center; justify-content:center}

    /* thin coord box styling */
    .coord-box{box-shadow:none}

  </style>
</head>
<body>
  <div class="topbar">
    <div class="title"><img src="./logo.png" width=50>gamble where you go</div>

    <div class="controls">
      <button id="selectBtn" class="btn">Select area</button>
      <button id="animateBtn" class="btn primary" disabled>Animate pointer</button>
      <button id="resetBtn" class="btn warn">Reset</button>
    </div>

  </div>

  <div id="map"></div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>

  <script>
    // Utility functions
    function randomLatLngInBounds(bounds){
      const sw = bounds.getSouthWest();
      const ne = bounds.getNorthEast();
      const lat = sw.lat + Math.random() * (ne.lat - sw.lat);
      const lng = sw.lng + Math.random() * (ne.lng - sw.lng);
      return [lat, lng];
    }
    function easeOutCubic(t){ return 1 - Math.pow(1 - t, 3); }

    // Create map
    const map = L.map('map', {worldCopyJump:true}).setView([20,0], 2);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    // State
    let selecting = false;
    let cornerA = null;
    let rect = null;
    let marker = null;
    let anim = { running:false, raf:null };

    // Drag-select state
    let dragSelecting = false;
    let dragStartPoint = null;
    let dragRect = null;

    // DOM
    const selectBtn = document.getElementById('selectBtn');
    const animateBtn = document.getElementById('animateBtn');
    const resetBtn = document.getElementById('resetBtn');
    const status = document.getElementById('status');

    selectBtn.addEventListener('click', ()=>{
      selecting = !selecting;
      if(selecting){
        cornerA = null;
        status.textContent = 'Selecting area: click first corner or drag';
        selectBtn.textContent = 'Cancel selection';
        // enable drag handlers
        map.getContainer().style.cursor = 'crosshair';
      } else {
        status.textContent = rect ? 'Area selected' : 'Selection cancelled';
        selectBtn.textContent = 'Select area';
        map.getContainer().style.cursor = '';
      }
    });

    resetBtn.addEventListener('click', ()=>{
      cancelAnimation();
      if(rect){ map.removeLayer(rect); rect = null; }
      if(marker){ map.removeLayer(marker); marker = null; }
      cornerA = null;
      selecting = false;
      selectBtn.textContent = 'Select area';
      animateBtn.disabled = true;
      status.textContent = 'Selection cleared';
      map.getContainer().style.cursor = '';
    });

    animateBtn.addEventListener('click', ()=>{
      if(!rect) return;
      startAnimation();
    });

    // Pointer icon using divIcon with SVG
    function createPointerIcon(size=36){
      const accent = getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#ff3e00';
      const svg = `
        <svg xmlns="http://www.w3.org/2000/svg" width="${size}" height="${size}" viewBox="0 0 24 24">
          <path fill="currentColor" d="M12 2L15 11H9L12 2z"/>
          <circle cx="12" cy="16" r="3" fill="currentColor" />
        </svg>
      `;
      return L.divIcon({
        className: 'map-pointer-icon',
        html: `<div style="font-size:14px; display:flex; align-items:center; justify-content:center; color:${accent}">${svg}</div>`,
        iconSize:[size, size],
        iconAnchor:[size/2, size/2]
      });
    }

    // Map click handler when selecting (supports two-click selection)
    map.on('click', function(e){
      if(!selecting) return;
      // ignore clicks while drag-select is active
      if(dragSelecting) return;
      const latlng = e.latlng;
      if(!cornerA){
        cornerA = latlng;
        status.textContent = 'Select opposite corner or drag';
      } else {
        finalizeBoundsFromTwoCorners(cornerA, latlng);
      }
    });

    function finalizeBoundsFromTwoCorners(a, b){
      const sw = L.latLng(Math.min(a.lat, b.lat), Math.min(a.lng, b.lng));
      const ne = L.latLng(Math.max(a.lat, b.lat), Math.max(a.lng, b.lng));
      const bounds = L.latLngBounds(sw, ne);
      if(rect) map.removeLayer(rect);
      rect = L.rectangle(bounds, {color: getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#ff3e00', weight:2, dashArray:'6 6'}).addTo(map);
      selecting = false;
      cornerA = null;
      selectBtn.textContent = 'Select area';
      animateBtn.disabled = false;
      status.textContent = `Area selected — SW: ${bounds.getSouthWest().lat.toFixed(3)}, ${bounds.getSouthWest().lng.toFixed(3)} — NE: ${bounds.getNorthEast().lat.toFixed(3)}, ${bounds.getNorthEast().lng.toFixed(3)}`;
    }

    // Drag-to-select handlers
    map.on('mousedown', function(e){
      if(!selecting) return;
      dragSelecting = true;
      dragStartPoint = e.latlng;
      if(dragRect) map.removeLayer(dragRect);
      dragRect = L.rectangle([dragStartPoint, dragStartPoint], {color: '#999', weight:1, dashArray:'4 4'}).addTo(map);
      // prevent map dragging while drawing
      map.dragging.disable();
    });

    map.on('mousemove', function(e){
      if(dragSelecting && dragRect){
        const sw = L.latLng(Math.min(dragStartPoint.lat, e.latlng.lat), Math.min(dragStartPoint.lng, e.latlng.lng));
        const ne = L.latLng(Math.max(dragStartPoint.lat, e.latlng.lat), Math.max(dragStartPoint.lng, e.latlng.lng));
        dragRect.setBounds(L.latLngBounds(sw, ne));
      }
    });

    map.on('mouseup', function(e){
      if(!dragSelecting) return;
      dragSelecting = false;
      map.dragging.enable();
      if(dragRect){
        // finalize rectangle
        const bounds = dragRect.getBounds();
        if(rect) map.removeLayer(rect);
        rect = L.rectangle(bounds, {color: getComputedStyle(document.documentElement).getPropertyValue('--accent').trim() || '#ff3e00', weight:2, dashArray:'6 6'}).addTo(map);
        map.removeLayer(dragRect);
        dragRect = null;
        selecting = false;
        selectBtn.textContent = 'Select area';
        animateBtn.disabled = false;
        status.textContent = `Area selected — SW: ${bounds.getSouthWest().lat.toFixed(3)}, ${bounds.getSouthWest().lng.toFixed(3)} — NE: ${bounds.getNorthEast().lat.toFixed(3)}, ${bounds.getNorthEast().lng.toFixed(3)}`;
      }
      dragStartPoint = null;
    });

    // If mouse leaves map while drawing, cancel
    map.getContainer().addEventListener('mouseleave', ()=>{
      if(dragSelecting){
        dragSelecting = false;
        if(dragRect){ map.removeLayer(dragRect); dragRect = null; }
        map.dragging.enable();
      }
    });

    // Animation helpers
    function cancelAnimation(){
      anim.running = false;
      if(anim.raf) cancelAnimationFrame(anim.raf);
      anim.raf = null;
      animateBtn.disabled = false;
      animateBtn.textContent = 'Animate pointer';
    }

    async function startAnimation(){
      if(!rect) return;
      cancelAnimation();
      anim.running = true;
      animateBtn.disabled = true;
      animateBtn.textContent = 'Animating...';

      const bounds = rect.getBounds();

      // pick final landing point
      const final = randomLatLngInBounds(bounds);

      // waypoints
      const waypoints = [];
      const hops = 10;
      for(let i=0;i<hops;i++) waypoints.push(randomLatLngInBounds(bounds));
      waypoints.push(final);

      const totalDuration = 4500; // ms
      const segments = waypoints.length;
      const perSegment = totalDuration / segments;

      let current = marker ? marker.getLatLng() : L.latLng(randomLatLngInBounds(bounds));
      if(marker) marker.setLatLng(current);
      else marker = L.marker(current, {icon:createPointerIcon(40)}).addTo(map);

      for(let s=0; s<segments && anim.running; s++){
        const next = L.latLng(waypoints[s][0], waypoints[s][1]);
        const startTime = performance.now();
        const endTime = startTime + perSegment;

        const wobbleBase = 0.01 * (1 - s / segments);

        await new Promise((resolve)=>{
          function step(now){
            if(!anim.running) return resolve();
            const t = (now - startTime) / (endTime - startTime);
            const te = Math.max(0, Math.min(1, easeOutCubic(t)));

            const lat = current.lat + (next.lat - current.lat) * te;
            const lng = current.lng + (next.lng - current.lng) * te;

            const angle = te * Math.PI * 2 * (3 + Math.random() * 4);
            const wobble = wobbleBase * Math.sin(angle) * (1 - te);
            const jitter = (Math.random() - 0.5) * wobbleBase * 0.2;

            const displayed = [lat + wobble + jitter, lng - wobble * 0.6 + jitter];
            marker.setLatLng(displayed);

            if(now >= endTime){
              current = next;
              marker.setLatLng(current);
              return resolve();
            }
            anim.raf = requestAnimationFrame(step);
          }
          anim.raf = requestAnimationFrame(step);
        });
      }

      anim.running = false;
      // final placement
      if(marker) marker.setLatLng(final);

      // nice little bounce to indicate final
      await bounceMarker(marker, final, 8, 0.0009);

      // show final coordinates in status and re-enable UI
      status.textContent = `Landing point: ${final[0].toFixed(5)}, ${final[1].toFixed(5)}`;
      animateBtn.disabled = false;
      animateBtn.textContent = 'Animate pointer';
    }

    // Bounce animation: vertical lat offsets with diminishing amplitude
    function bounceMarker(marker, centerLatLng, steps=8, amplitude=0.001){
      return new Promise((resolve)=>{
        let start = performance.now();
        const duration = 600; // ms
        function frame(now){
          const t = (now - start) / duration;
          if(t >= 1){
            marker.setLatLng(centerLatLng);
            return resolve();
          }
          // damping sine
          const damp = Math.exp(-3 * t);
          const y = Math.sin(t * Math.PI * 4) * amplitude * damp;
          marker.setLatLng([centerLatLng[0] + y, centerLatLng[1]]);
          requestAnimationFrame(frame);
        }
        requestAnimationFrame(frame);
      });
    }

    // keyboard: press Escape to cancel selection or animation
    window.addEventListener('keydown', (e)=>{
      if(e.key === 'Escape'){
        selecting = false;
        cornerA = null;
        selectBtn.textContent = 'Select area';
        status.textContent = rect ? 'Area selected' : 'Idle';
        cancelAnimation();
      }
    });

    // small usability: show coordinates on hover
    const coordBox = L.control({position:'bottomleft'});
    coordBox.onAdd = function(){
      const div = L.DomUtil.create('div','coord-box');
      div.style.padding = '6px 8px';
      div.style.background = 'rgba(0,0,0,0.35)';
      div.style.borderRadius = '6px';
      div.style.fontSize = '12px';
      div.style.color = '#dfe9f2';
      div.style.pointerEvents = 'none';
      div.textContent = '';
      return div;
    };
    coordBox.addTo(map);
    map.on('mousemove', function(e){
      const div = document.querySelector('.coord-box');
      if(div) div.textContent = `${e.latlng.lat.toFixed(4)}, ${e.latlng.lng.toFixed(4)}`;
    });

    // initial hint
    status.textContent = 'Click "Select area" then click map twice or drag to set rectangle';

  </script>
</body>
</html>
